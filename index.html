<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>AR Interaction Lab (Grades 7, 9, 10)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />

  <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/build/aframe-ar.js"></script>

  <style>
    body { 
        margin:0; 
        overflow:hidden; 
        /* CRITICAL: Prevents browser zooming/scrolling while gesturing */
        touch-action: none; 
    }
    
    /* HUD / UI Styling */
    .hud {
      position: fixed; bottom: 14px; left: 50%; transform: translateX(-50%);
      display: grid; grid-template-columns: repeat(5, auto); gap: 8px;
      font: 600 14px/1 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      z-index: 10; pointer-events: none;
    }
    .hud.hidden { display: none; }
    .hud button {
      pointer-events: auto;
      padding: 10px 12px; border: 0; border-radius: 10px;
      background: rgba(255,255,255,.9);
      font-size: 20px;
    }
  </style>

  <script>
  // ---------- Utilities ----------
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

  // --- [Grade 7] --- Global state for sequential markers
  let marker1Found = false;

  // --- [Grade 7] --- Logic to manage object visibility based on sequence
  AFRAME.registerComponent('marker-logic', {
    init: function () {
      this.modelIsReady = false;
      this.markerIsVisible = false;

      this.el.addEventListener('model-loaded', () => {
        this.modelIsReady = true;
        this.checkVisibility();
      });

      this.el.sceneEl.addEventListener('markerFound', (e) => {
        if (this.el.parentNode.id === e.target.id) {
          this.markerIsVisible = true;
          this.checkVisibility();
        }
      });
      
      this.el.sceneEl.addEventListener('markerLost', (e) => {
        if (this.el.parentNode.id === e.target.id) {
          this.markerIsVisible = false;
          this.checkVisibility();
        }
      });
    },

    checkVisibility: function () {
      if (this.modelIsReady && this.markerIsVisible && marker1Found) {
        this.el.setAttribute('visible', true);
      } else {
        this.el.setAttribute('visible', false);
      }
    }
  });

  // ---------- CRITICAL: Gesture Detector (Updated for Twist) ----------
  // Detects pinch (spread) and twist (angle) gestures
  AFRAME.registerComponent('gesture-detector', {
    schema: { element: { default: '' } },
    init: function() {
      this.targetElement = this.data.element && document.querySelector(this.data.element);
      if (!this.targetElement) { this.targetElement = this.el; }
      this.internalState = { previousState: null };
      this.emitGestureEvent = this.emitGestureEvent.bind(this);
      this.targetElement.addEventListener("touchstart", this.emitGestureEvent);
      this.targetElement.addEventListener("touchend", this.emitGestureEvent);
      this.targetElement.addEventListener("touchmove", this.emitGestureEvent);
    },
    remove: function() {
      this.targetElement.removeEventListener("touchstart", this.emitGestureEvent);
      this.targetElement.removeEventListener("touchend", this.emitGestureEvent);
      this.targetElement.removeEventListener("touchmove", this.emitGestureEvent);
    },
    emitGestureEvent: function(event) {
      if (event.type === "touchstart") {
        this.internalState.previousState = event.touches.length === 2 ? this.getTouchState(event) : null;
        return;
      }
      if (event.type === "touchend") {
        this.internalState.previousState = null;
        return;
      }
      if (event.touches.length !== 2) return;
      
      const currentState = this.getTouchState(event);
      const previousState = this.internalState.previousState;
      
      if (previousState) {
        const spreadChange = currentState.spread - previousState.spread;
        
        // Calculate angle change for twist
        let rotationChange = currentState.angle - previousState.angle;
        // Fix angle wrap-around (e.g. going from 179 to -179 degrees)
        if (rotationChange > Math.PI) rotationChange -= Math.PI * 2;
        if (rotationChange < -Math.PI) rotationChange += Math.PI * 2;

        const positionChange = {
          x: currentState.position.x - previousState.position.x,
          y: currentState.position.y - previousState.position.y
        };
        
        this.el.emit("twofingermove", {
          positionChange: positionChange,
          spreadChange: spreadChange,
          rotationChange: rotationChange,
          startSpread: previousState.spread,
          position: currentState.position
        });
      }
      this.internalState.previousState = currentState;
    },
    getTouchState: function(event) {
      if (event.touches.length < 2) return null;
      const touch0 = event.touches[0];
      const touch1 = event.touches[1];
      const dx = touch0.clientX - touch1.clientX;
      const dy = touch0.clientY - touch1.clientY;
      return {
        spread: Math.sqrt(dx * dx + dy * dy),
        angle: Math.atan2(dy, dx), // Calculate angle for twisting
        position: {
          x: (touch0.clientX + touch1.clientX) / 2,
          y: (touch0.clientY + touch1.clientY) / 2
        }
      };
    }
  });

  // ---------- 1) Tap / Doubletap / Longpress (Mobile Fix) ----------
  AFRAME.registerComponent('tap-gestures', {
    schema: {longMs: {default: 500}},
    init: function () {
      let timer = null;
      let lastTap = 0;

      const startHandler = (e) => {
        // Only tracking single touch/click interactions here
        if (e.touches && e.touches.length > 1) return;

        const now = Date.now();
        const timeSinceLastTap = now - lastTap;

        if (timeSinceLastTap < 300 && timeSinceLastTap > 0) {
          this.el.emit('doubletap');
          clearTimeout(timer); 
        } else {
          timer = setTimeout(() => {
            this.el.emit('longpress');
          }, this.data.longMs);
        }
        lastTap = now;
      };

      const endHandler = (e) => {
         clearTimeout(timer); 
         if (Date.now() - lastTap < 300) {
             this.el.emit('tap');
         }
      };

      this.el.addEventListener('mousedown', startHandler);
      this.el.addEventListener('touchstart', startHandler);
      this.el.addEventListener('mouseup', endHandler);
      this.el.addEventListener('touchend', endHandler);
    }
  });

  // ---------- 2) Drag on a plane (Mobile Fix) ----------
  AFRAME.registerComponent('drag-on-plane', {
    schema: {
      plane: {type: 'selector'},
      yOffset: {default: 0.1},
      radius: {default: 2.0}
    },
    init: function () {
      this.isDragging = false;
      this.raycaster = new THREE.Raycaster();
      this.plane = this.data.plane.object3D;

      this.el.addEventListener('mousedown', this.onDown.bind(this));
      this.el.addEventListener('touchstart', this.onDown.bind(this));

      window.addEventListener('mousemove', this.onMove.bind(this));
      window.addEventListener('touchmove', this.onMove.bind(this));
      
      window.addEventListener('mouseup', this.onUp.bind(this));
      window.addEventListener('touchend', this.onUp.bind(this));
    },
    onDown: function (e) {
      // Only allow drag if EXACTLY 1 finger (or mouse)
      if (e.touches && e.touches.length !== 1) return;
      this.isDragging = true;
    },
    onUp: function () {
      this.isDragging = false;
    },
    onMove: function (e) {
      if (!this.isDragging) return;
      // Strict check: Stop dragging if a second finger touches
      if (e.touches && e.touches.length !== 1) {
        this.isDragging = false;
        return;
      }

      let clientX, clientY;
      if (e.touches) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
      } else {
        clientX = e.clientX;
        clientY = e.clientY;
      }

      const mouse = new THREE.Vector2();
      mouse.x = (clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(clientY / window.innerHeight) * 2 + 1;

      this.raycaster.setFromCamera(mouse, this.el.sceneEl.camera);
      const intersects = this.raycaster.intersectObject(this.plane, true);

      if (intersects.length > 0) {
        let point = intersects[0].point;
        this.el.parentEl.object3D.worldToLocal(point);

        const dist = Math.sqrt(point.x * point.x + point.z * point.z);
        if (dist > this.data.radius) {
          const ratio = this.data.radius / dist;
          point.x *= ratio;
          point.z *= ratio;
        }

        this.el.setAttribute('position', {
          x: point.x,
          y: this.data.yOffset,
          z: point.z
        });
      }
    }
  });

  // ---------- 3 & 4) Gesture Handler (Twist-Rotate & Pinch-Scale) ----------
  AFRAME.registerComponent('gesture-handler', {
    schema: {
      enabled: { default: true },
      rotationFactor: { default: 5 }, // Multiplier for rotation speed
      minScale: { default: 0.1 },
      maxScale: { default: 5 },
    },
    init: function () {
      this.handleScale = this.handleScale.bind(this);
      this.handleRotation = this.handleRotation.bind(this);
      this.isVisible = false;
      this.initialScale = this.el.object3D.scale.clone();
      this.scaleFactor = 1;

      this.el.sceneEl.addEventListener("markerFound", (e) => {
        // Only set visible if THIS element is inside the found marker
        if (e.target.contains(this.el)) this.isVisible = true;
      });
      this.el.sceneEl.addEventListener("markerLost", (e) => {
        if (e.target.contains(this.el)) this.isVisible = false;
      });
    },
    update: function () {
      if (this.data.enabled) {
        this.el.sceneEl.addEventListener("twofingermove", this.handleRotation);
        this.el.sceneEl.addEventListener("twofingermove", this.handleScale);
      } else {
        this.el.sceneEl.removeEventListener("twofingermove", this.handleRotation);
        this.el.sceneEl.removeEventListener("twofingermove", this.handleScale);
      }
    },
    remove: function () {
      this.el.sceneEl.removeEventListener("twofingermove", this.handleRotation);
      this.el.sceneEl.removeEventListener("twofingermove", this.handleScale);
    },
    handleRotation: function (event) {
      if (this.isVisible) {
        // Use rotationChange (angle difference) instead of positionChange (pan)
        // -1 factor makes the rotation follow fingers naturally
        this.el.object3D.rotation.y -= event.detail.rotationChange * this.data.rotationFactor;
      }
    },
    handleScale: function (event) {
      if (this.isVisible) {
        this.scaleFactor *= 1 + event.detail.spreadChange / event.detail.startSpread;
        this.scaleFactor = Math.min(Math.max(this.scaleFactor, this.data.minScale), this.data.maxScale);
        this.el.object3D.scale.x = this.scaleFactor * this.initialScale.x;
        this.el.object3D.scale.y = this.scaleFactor * this.initialScale.y;
        this.el.object3D.scale.z = this.scaleFactor * this.initialScale.z;
      }
    },
  });

  // ---------- 5) Spin toggler + random color ----------
  AFRAME.registerComponent('spin-toggle', {
    schema:{speed:{default:4000}},
    init(){
      this.spinning = false;
      this.el.addEventListener('toggle-spin', ()=> {
        this.spinning = !this.spinning;
        if (this.spinning) {
          this.el.setAttribute('animation__spin',
            `property: rotation; to: 0 360 0; loop: true; dur: ${this.data.speed}`);
        } else {
          this.el.removeAttribute('animation__spin');
        }
      });
      this.el.addEventListener('random-color', ()=> {
        if (this.el.nodeName.toLowerCase() === 'a-box') {
          const colors = ['#4CC3D9','#FFC65D','#7BC8A4','#EF2D5E','#FFFFFF'];
          const c = colors[Math.floor(Math.random()*colors.length)];
          this.el.setAttribute('material','color',c);
        }
      });
    }
  });
  </script>
</head>
<body>
  <div class="hud" id="hud">
    <button id="btn-rot-l">âŸ²</button>
    <button id="btn-rot-r">âŸ³</button>
    <button id="btn-scale--">âˆ’</button>
    <button id="btn-scale-+">ï¼‹</button>
    <button id="btn-color">ðŸŽ¨</button>
  </div>

  <a-scene
    embedded
    gesture-detector
    renderer="colorManagement: true; physicallyCorrectLights: true"
    xr-mode-ui="enabled: false"
    arjs="sourceType: webcam; debugUIEnabled: false; detectionMode: mono_and_matrix; matrixCodeType: 3x3;">

    <a-entity camera mouse-cursor position="0 0 0">
        <a-entity cursor="fuse: false; rayOrigin: mouse;" raycaster="objects: .raytarget"></a-entity>
    </a-entity>

    <a-entity light="type: ambient; intensity: 0.8"></a-entity>
    <a-entity light="type: directional; intensity: 0.6" position="0 1 1"></a-entity>

    <a-marker type="pattern" url="salute.patt" id="marker1">
      <a-plane id="dragplane1" class="raytarget"
               position="0 0 0" rotation="-90 0 0" width="10" height="10"
               material="opacity: 0; transparent: true"></a-plane>

      <a-box id="cube" class="raytarget"
             position="0 0.25 0" depth="0.5" height="0.5" width="0.5"
             material="metalness:0.1; roughness:0.6; color:#4CC3D9"
             tap-gestures 
             spin-toggle
             drag-on-plane="plane: #dragplane1; yOffset: 0.25; radius: 2.0"
             gesture-handler="minScale: 0.2; maxScale: 3; rotationFactor: 2">
      </a-box>
    </a-marker>
    
    <a-marker type="pattern" url="ronnieradke.patt" id="marker2">
      <a-plane id="dragplane2" class="raytarget"
               position="0 0 0" rotation="-90 0 0" width="10" height="10"
               material="opacity: 0; transparent: true"></a-plane>

      <a-gltf-model id="model" src="scene.gltf" class="raytarget"
              position="0 0.1 0" scale="0.1 0.1 0.1" 
              marker-logic
              tap-gestures 
              spin-toggle
              drag-on-plane="plane: #dragplane2; yOffset: 0.1; radius: 2.0"
              gesture-handler="minScale: 0.05; maxScale: 2; rotationFactor: 2">
              
          <a-box color="red" position="0 0.5 0" scale="0.5 0.5 0.5"></a-box>
      </a-gltf-model>
    </a-marker>

  </a-scene>

  <script>
    const hud  = document.getElementById('hud');
    const cube = document.getElementById('cube');
    const model = document.getElementById('model');

    // Listen for model errors
    model.addEventListener('model-error', (e) => {
      console.error('*** DEBUG: MODEL FAILED TO LOAD ***', e.detail);
    });

    // --- [Grade 7] --- Listen for marker1 to be found
    document.getElementById('marker1').addEventListener('markerFound', () => {
      console.log('DEBUG: Marker 1 (Salute) FOUND. Sequence Unlocked.');
      marker1Found = true;
      
      // Update logic in case Marker 2 is already in view
      if (model.components['marker-logic']) {
        model.components['marker-logic'].checkVisibility();
      }
    });

    // --- HUD Button Logic ---
    function getActiveObject() {
      if (model && model.getAttribute('visible') === true) return model;
      if (cube) return cube;
      return null;
    }

    document.getElementById('btn-rot-l').addEventListener('click', () => nudgeRot(-15));
    document.getElementById('btn-rot-r').addEventListener('click', () => nudgeRot( 15));
    function nudgeRot(delta){
      const obj = getActiveObject();
      if (!obj) return;
      const r = obj.getAttribute('rotation');
      const rad = THREE.Math.degToRad(delta); // Convert degrees to radians if modifying object3D directly, but here we use setAttribute which takes degrees
      obj.setAttribute('rotation', {x:r.x, y:r.y + delta, z:r.z});
    }

    document.getElementById('btn-scale--').addEventListener('click', () => nudgeScale(0.9));
    document.getElementById('btn-scale-+').addEventListener('click', () => nudgeScale(1.1));
    function nudgeScale(mult){
      const obj = getActiveObject();
      if (!obj) return;
      
      const s = obj.getAttribute('scale');
      const minScale = (obj.id === 'model') ? 0.1 : 0.2;
      const maxScale = (obj.id === 'model') ? 5 : 3;

      obj.setAttribute('scale', {
        x: clamp(s.x * mult, minScale, maxScale),
        y: clamp(s.y * mult, minScale, maxScale),
        z: clamp(s.z * mult, minScale, maxScale)
      });
    }

    document.getElementById('btn-color').addEventListener('click', () => {
        const obj = getActiveObject();
        if (obj) obj.emit('random-color');
    });

    // Gesture hooks (Taps)
    cube.addEventListener('tap',       () => cube.emit('toggle-spin'));
    cube.addEventListener('doubletap', () => cube.emit('random-color'));
    cube.addEventListener('longpress', () => hud.classList.toggle('hidden'));
    
    model.addEventListener('tap',       () => model.emit('toggle-spin'));
    model.addEventListener('doubletap', () => model.emit('random-color'));
    model.addEventListener('longpress', () => hud.classList.toggle('hidden'));
  </script>
</body>
</html>
